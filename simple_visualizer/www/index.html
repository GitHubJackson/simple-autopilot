<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <title>Autopilot Visualizer</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        height: 100vh;
        background-color: #1e1e1e;
        color: #e0e0e0;
      }
      #sidebar {
        width: 300px;
        padding: 20px;
        background-color: #252526;
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      #main-view {
        flex-grow: 1;
        position: relative;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #000;
      }
      canvas {
        background-color: #121212;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      }
      .control-group {
        background: #333;
        padding: 15px;
        border-radius: 8px;
      }
      .control-group h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 16px;
        color: #fff;
        border-bottom: 1px solid #444;
        padding-bottom: 5px;
      }
      .param-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      input[type="range"] {
        width: 100%;
        margin: 10px 0;
      }
      button {
        width: 100%;
        padding: 10px;
        background-color: #007acc;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background 0.2s;
      }
      button:hover {
        background-color: #005999;
      }
      button.danger {
        background-color: #d83b01;
      }
      button.danger:hover {
        background-color: #a82b01;
      }
      .status-tag {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
      }
      .status-connected {
        background-color: #1e7e34;
        color: white;
      }
      .status-disconnected {
        background-color: #bd2130;
        color: white;
      }
      #telemetry {
        font-family: monospace;
        font-size: 12px;
        line-height: 1.5;
      }
    </style>
  </head>
  <body>
    <div id="sidebar">
      <div class="control-group">
        <h3>Connection</h3>
        <div id="connection-status" class="status-tag status-disconnected">
          Disconnected
        </div>
      </div>

      <div class="control-group">
        <h3>Vehicle Control</h3>

        <div style="margin-bottom: 10px">
          <button onclick="sendCommand('set_target', 0)">
            Go to Origin (0,0)
          </button>
          <button onclick="sendCommand('set_target', 1)">
            Go to Target (30,10)
          </button>
        </div>

        <label>Target Speed: <span id="speed-val">0</span> m/s</label>
        <input
          type="range"
          id="speed-input"
          min="0"
          max="30"
          step="1"
          value="0"
        />

        <label>Steering: <span id="steer-val">0</span> rad</label>
        <input
          type="range"
          id="steer-input"
          min="-0.5"
          max="0.5"
          step="0.05"
          value="0"
        />

        <div style="margin-top: 15px; display: flex; gap: 10px">
          <button class="danger" onclick="sendCommand('reset')">
            Reset State
          </button>
          <button onclick="sendCommand('stop')">Emergency Stop</button>
        </div>
      </div>

      <div class="control-group">
        <h3>Telemetry</h3>
        <div id="telemetry">Waiting for data...</div>
      </div>

      <div class="control-group">
        <h3>View Options</h3>
        <label
          ><input type="checkbox" id="follow-cam" checked /> Follow Car</label
        >
      </div>
    </div>

    <div id="main-view">
      <canvas id="viz-canvas" width="800" height="600"></canvas>
      <div
        style="
          position: absolute;
          top: 10px;
          right: 10px;
          background: rgba(0, 0, 0, 0.7);
          padding: 5px;
          border: 1px solid #444;
        "
      >
        <div style="color: #ccc; font-size: 12px; margin-bottom: 5px">
          Camera Feed (Fused)
        </div>
        <canvas
          id="camera-canvas"
          width="160"
          height="120"
          style="background: #000; border: 1px solid #333"
        ></canvas>
      </div>
    </div>

    <script>
      // --- WebSocket Connection ---
      const wsProtocol =
        window.location.protocol === "https:" ? "wss://" : "ws://";
      const wsUrl = wsProtocol + window.location.host + "/ws";
      let socket;
      let isConnected = false;

      // --- State ---
      let carState = { x: 0, y: 0, heading: 0, speed: 0, steering: 0 };
      let obstacles = [];
      let planningTrajectory = []; // 存储规划轨迹点
      let predictionTrajectories = {}; // 存储预测轨迹 {obstacle_id: [trajectory_points]}
      let mapLanes = []; // 存储地图车道线
      let frameId = 0;

      // --- Canvas Setup ---
      const canvas = document.getElementById("viz-canvas");
      const ctx = canvas.getContext("2d");

      const camCanvas = document.getElementById("camera-canvas");
      const camCtx = camCanvas.getContext("2d");
      // 创建 ImageData 对象缓存 (160x120)
      let camImageData = camCtx.createImageData(160, 120);

      const PIXELS_PER_METER = 10;
      const VIEW_WIDTH_METERS = canvas.width / PIXELS_PER_METER;
      const VIEW_HEIGHT_METERS = canvas.height / PIXELS_PER_METER;

      function connect() {
        socket = new WebSocket(wsUrl);
        socket.binaryType = "arraybuffer"; // 重要：接收二进制数据

        socket.onopen = () => {
          isConnected = true;
          document.getElementById("connection-status").className =
            "status-tag status-connected";
          document.getElementById("connection-status").innerText = "Connected";
          console.log("WebSocket connected");
        };

        socket.onclose = () => {
          isConnected = false;
          document.getElementById("connection-status").className =
            "status-tag status-disconnected";
          document.getElementById("connection-status").innerText =
            "Disconnected";
          console.log("WebSocket disconnected, retrying in 3s...");
          setTimeout(connect, 3000);
        };

        socket.onmessage = (event) => {
          try {
            if (typeof event.data === "string") {
              // 添加原始数据日志（仅对地图和预测数据）
              if (
                event.data.includes("map_data") ||
                event.data.includes("prediction_trajectories")
              ) {
                console.log(
                  "Raw WebSocket data received:",
                  event.data.substring(0, 200) + "..."
                );
              }
              const msg = JSON.parse(event.data);
              if (msg.type === "frame_data" || msg.frame_id !== undefined) {
                // 后端发送的是 frame_id (下划线)，不是 frameId (驼峰)
                handleFrameData(msg);
              } else if (msg.type === "planning_trajectory") {
                // 处理 Planning 轨迹
                planningTrajectory = msg.trajectory || [];
                draw();
              } else if (msg.type === "prediction_trajectories") {
                // 处理预测轨迹
                console.log("Received prediction_trajectories:", msg);
                console.log(
                  "msg.obstacles type:",
                  typeof msg.obstacles,
                  "isArray:",
                  Array.isArray(msg.obstacles),
                  "length:",
                  msg.obstacles ? msg.obstacles.length : 0
                );

                predictionTrajectories = {};
                if (msg.obstacles && Array.isArray(msg.obstacles)) {
                  console.log("Processing", msg.obstacles.length, "obstacles");
                  for (const obs of msg.obstacles) {
                    console.log(
                      "Obstacle",
                      obs.id,
                      "trajectory:",
                      obs.trajectory
                        ? Array.isArray(obs.trajectory)
                          ? obs.trajectory.length + " points"
                          : "not array"
                        : "missing"
                    );
                    if (obs.trajectory && Array.isArray(obs.trajectory)) {
                      if (obs.trajectory.length > 0) {
                        predictionTrajectories[obs.id] = obs.trajectory;
                        console.log(
                          "Added prediction for obstacle",
                          obs.id,
                          "with",
                          obs.trajectory.length,
                          "points, first point:",
                          obs.trajectory[0]
                        );
                      } else {
                        console.warn("Empty trajectory for obstacle", obs.id);
                      }
                    } else {
                      console.warn(
                        "Invalid trajectory for obstacle",
                        obs.id,
                        ":",
                        obs.trajectory
                      );
                    }
                  }
                } else {
                  console.warn(
                    "No obstacles array in prediction_trajectories message"
                  );
                }
                console.log(
                  "Total prediction trajectories:",
                  Object.keys(predictionTrajectories).length
                );
                draw();
              } else if (msg.type === "map_data") {
                // 处理地图数据
                console.log("Received map_data:", msg);
                console.log(
                  "msg.lanes type:",
                  typeof msg.lanes,
                  "isArray:",
                  Array.isArray(msg.lanes),
                  "length:",
                  msg.lanes ? msg.lanes.length : 0
                );

                if (!msg.lanes || !Array.isArray(msg.lanes)) {
                  console.error("Invalid lanes data:", msg.lanes);
                  return;
                }

                mapLanes = msg.lanes.map((lane) => {
                  console.log(
                    "Processing lane:",
                    lane.id,
                    "center_line:",
                    lane.center_line ? lane.center_line.length : 0,
                    "points"
                  );

                  const mapped = {
                    id: lane.id,
                    centerLine: lane.center_line || [],
                    leftBoundary: lane.left_boundary || [],
                    rightBoundary: lane.right_boundary || [],
                    width: lane.width || 3.5,
                    leftLaneId: lane.left_lane_id || -1,
                    rightLaneId: lane.right_lane_id || -1,
                    type: lane.type || "straight",
                  };

                  // 验证数据
                  if (!mapped.centerLine || !Array.isArray(mapped.centerLine)) {
                    console.error(
                      "Invalid centerLine for lane",
                      mapped.id,
                      ":",
                      mapped.centerLine
                    );
                  } else if (mapped.centerLine.length === 0) {
                    console.warn("Empty centerLine for lane", mapped.id);
                  } else {
                    console.log(
                      "Lane",
                      mapped.id,
                      "has",
                      mapped.centerLine.length,
                      "centerLine points, first point:",
                      mapped.centerLine[0]
                    );
                  }

                  return mapped;
                });
                console.log("Total lanes mapped:", mapLanes.length);
                draw();
              }
            } else if (event.data instanceof ArrayBuffer) {
              // 处理图片数据 [W:4][H:4][RGB...]
              handleCameraData(event.data);
            }
          } catch (e) {
            console.error("Parse error:", e, "data:", event.data);
            // 如果是字符串，尝试直接解析
            if (typeof event.data === "string") {
              try {
                const msg = JSON.parse(event.data);
                console.log("Successfully parsed after error:", msg);
                // 重新处理消息
                if (msg.type === "map_data") {
                  console.log("Processing map_data after error recovery");
                  mapLanes = (msg.lanes || []).map((lane) => {
                    const mapped = {
                      id: lane.id,
                      centerLine: lane.center_line || [],
                      leftBoundary: lane.left_boundary || [],
                      rightBoundary: lane.right_boundary || [],
                      width: lane.width || 3.5,
                      leftLaneId: lane.left_lane_id || -1,
                      rightLaneId: lane.right_lane_id || -1,
                      type: lane.type || "straight",
                    };
                    return mapped;
                  });
                  console.log("Total lanes after recovery:", mapLanes.length);
                  draw();
                } else if (msg.type === "prediction_trajectories") {
                  console.log(
                    "Processing prediction_trajectories after error recovery"
                  );
                  predictionTrajectories = {};
                  if (msg.obstacles && Array.isArray(msg.obstacles)) {
                    for (const obs of msg.obstacles) {
                      if (obs.trajectory && Array.isArray(obs.trajectory)) {
                        predictionTrajectories[obs.id] = obs.trajectory;
                      }
                    }
                  }
                  draw();
                }
              } catch (e2) {
                console.error("Recovery parse error:", e2);
              }
            }
          }
        };
      }

      function handleCameraData(buffer) {
        const view = new DataView(buffer);
        const width = view.getUint32(0); // Big Endian by default? check C++ implementation
        // Actually C++ code used (val >> 24) etc, which is Big Endian manually constructed
        const height = view.getUint32(4);

        if (width !== camCanvas.width || height !== camCanvas.height) {
          camCanvas.width = width;
          camCanvas.height = height;
          camImageData = camCtx.createImageData(width, height);
        }

        const rgbData = new Uint8Array(buffer, 8);
        const len = width * height;

        // RGB -> RGBA
        for (let i = 0; i < len; i++) {
          camImageData.data[i * 4 + 0] = rgbData[i * 3 + 0]; // R
          camImageData.data[i * 4 + 1] = rgbData[i * 3 + 1]; // G
          camImageData.data[i * 4 + 2] = rgbData[i * 3 + 2]; // B
          camImageData.data[i * 4 + 3] = 255; // Alpha
        }

        camCtx.putImageData(camImageData, 0, 0);
      }

      function handleFrameData(data) {
        // 后端发送的是下划线命名 (car_state)，不是驼峰命名 (carState)
        const car = data.car_state || {};
        const pos = car.position || { x: 0, y: 0, z: 0 };

        carState = {
          x: pos.x || 0,
          y: pos.y || 0,
          heading: car.heading || 0,
          speed: car.speed || 0,
          steering: car.steering_angle || 0,
        };

        obstacles = data.obstacles || [];
        frameId = data.frame_id || 0;

        updateUI();
        draw();
      }

      function updateUI() {
        document.getElementById("telemetry").innerHTML = `
            Frame: ${frameId}<br>
            X: ${carState.x.toFixed(2)} m<br>
            Y: ${carState.y.toFixed(2)} m<br>
            Heading: ${((carState.heading * 180) / Math.PI).toFixed(1)}°<br>
            Speed: ${carState.speed.toFixed(1)} m/s<br>
            Steer: ${carState.steering.toFixed(2)} rad
        `;
      }

      // --- Controls ---
      const speedInput = document.getElementById("speed-input");
      const steerInput = document.getElementById("steer-input");

      speedInput.addEventListener("input", (e) => {
        document.getElementById("speed-val").innerText = e.target.value;
        sendWsCommand("set_speed", parseFloat(e.target.value));
      });

      steerInput.addEventListener("input", (e) => {
        document.getElementById("steer-val").innerText = e.target.value;
        sendWsCommand("set_steer", parseFloat(e.target.value));
      });

      // function sendCommand(cmd, value = 0) { ... } // Removed

      // Emergency stop helper
      window.sendCommand = (cmd, arg) => {
        if (cmd === "stop") {
          speedInput.value = 0;
          document.getElementById("speed-val").innerText = "0";
          sendWsCommand("stop");
        } else if (cmd === "set_target") {
          if (arg === 0) sendWsCommand("set_target", { x: 0, y: 0 });
          if (arg === 1) sendWsCommand("set_target", { x: 30, y: 10 });
        } else {
          sendWsCommand(cmd, arg);
        }
      };

      function sendWsCommand(cmd, val) {
        if (!isConnected) return;
        const msg = { cmd: cmd };
        if (typeof val === "object") {
          msg.x = val.x;
          msg.y = val.y;
        } else {
          msg.value = val;
        }
        socket.send(JSON.stringify(msg));
      }

      // --- Rendering ---
      let drawCallCount = 0; // 用于调试计数
      function worldToScreen(wx, wy) {
        let cx = 0;
        let cy = 0;

        if (document.getElementById("follow-cam").checked) {
          cx = carState.x;
          cy = carState.y;
        }

        // Center of screen
        const sx = (wx - cx) * PIXELS_PER_METER + canvas.width / 2;
        // Invert Y for screen coordinates (up is -y)
        const sy = canvas.height / 2 - (wy - cy) * PIXELS_PER_METER;

        return { x: sx, y: sy };
      }

      function draw() {
        drawCallCount++;
        // Clear background
        ctx.fillStyle = "#121212";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw Grid (every 10 meters)
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;

        let cx = document.getElementById("follow-cam").checked ? carState.x : 0;
        let cy = document.getElementById("follow-cam").checked ? carState.y : 0;

        const startX = Math.floor((cx - VIEW_WIDTH_METERS / 2) / 10) * 10;
        const endX = Math.ceil((cx + VIEW_WIDTH_METERS / 2) / 10) * 10;
        const startY = Math.floor((cy - VIEW_HEIGHT_METERS / 2) / 10) * 10;
        const endY = Math.ceil((cy + VIEW_HEIGHT_METERS / 2) / 10) * 10;

        ctx.beginPath();
        for (let x = startX; x <= endX; x += 10) {
          const p = worldToScreen(x, 0);
          ctx.moveTo(p.x, 0);
          ctx.lineTo(p.x, canvas.height);
        }
        for (let y = startY; y <= endY; y += 10) {
          const p = worldToScreen(0, y);
          ctx.moveTo(0, p.y);
          ctx.lineTo(canvas.width, p.y);
        }
        ctx.stroke();

        // Draw Origin
        const origin = worldToScreen(0, 0);
        ctx.fillStyle = "#666";
        ctx.beginPath();
        ctx.arc(origin.x, origin.y, 5, 0, Math.PI * 2);
        ctx.fill();

        // Draw Target Line
        ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        const p1 = worldToScreen(0, 0);
        const p2 = worldToScreen(30, 10);
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw Map Lanes
        if (mapLanes.length === 0) {
          // 只在每100次绘制时打印，避免日志过多
          if (drawCallCount % 100 === 0) {
            console.warn(
              "No map lanes to draw (draw call:",
              drawCallCount,
              ")"
            );
          }
        } else if (drawCallCount % 10 === 0) {
          // 每10次绘制打印一次
          console.log("Drawing", mapLanes.length, "lanes");
        }
        mapLanes.forEach((lane) => {
          if (!lane.centerLine || lane.centerLine.length === 0) {
            console.warn(
              "Lane",
              lane.id,
              "has no centerLine, centerLine=",
              lane.centerLine
            );
            return;
          }

          // 绘制左边界（黄色虚线）
          if (lane.leftBoundary && lane.leftBoundary.length > 0) {
            ctx.strokeStyle = "#ffaa00"; // 黄色
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]); // 虚线
            ctx.beginPath();
            const startLeft = worldToScreen(
              lane.leftBoundary[0].x,
              lane.leftBoundary[0].y
            );
            ctx.moveTo(startLeft.x, startLeft.y);
            for (let i = 1; i < lane.leftBoundary.length; i++) {
              const pt = worldToScreen(
                lane.leftBoundary[i].x,
                lane.leftBoundary[i].y
              );
              ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
          }

          // 绘制中心线（灰色实线）
          ctx.strokeStyle = "#888"; // 灰色
          ctx.lineWidth = 2;
          ctx.beginPath();
          const start = worldToScreen(
            lane.centerLine[0].x,
            lane.centerLine[0].y
          );
          ctx.moveTo(start.x, start.y);
          for (let i = 1; i < lane.centerLine.length; i++) {
            const pt = worldToScreen(
              lane.centerLine[i].x,
              lane.centerLine[i].y
            );
            ctx.lineTo(pt.x, pt.y);
          }
          ctx.stroke();

          // 绘制右边界（黄色虚线）
          if (lane.rightBoundary && lane.rightBoundary.length > 0) {
            ctx.strokeStyle = "#ffaa00"; // 黄色
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]); // 虚线
            ctx.beginPath();
            const startRight = worldToScreen(
              lane.rightBoundary[0].x,
              lane.rightBoundary[0].y
            );
            ctx.moveTo(startRight.x, startRight.y);
            for (let i = 1; i < lane.rightBoundary.length; i++) {
              const pt = worldToScreen(
                lane.rightBoundary[i].x,
                lane.rightBoundary[i].y
              );
              ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
          }

          // Draw Lane ID
          if (lane.centerLine.length > 0) {
            const midIdx = Math.floor(lane.centerLine.length / 2);
            const midPt = worldToScreen(
              lane.centerLine[midIdx].x,
              lane.centerLine[midIdx].y
            );
            ctx.fillStyle = "#aaa";
            ctx.font = "10px monospace";
            ctx.fillText(`L${lane.id}`, midPt.x, midPt.y);
          }
        });

        // Draw Planning Trajectory
        if (planningTrajectory.length > 0) {
          ctx.strokeStyle = "#00ffcc"; // 青色
          ctx.lineWidth = 3;
          ctx.beginPath();
          const start = worldToScreen(
            planningTrajectory[0].x,
            planningTrajectory[0].y
          );
          ctx.moveTo(start.x, start.y);
          for (let i = 1; i < planningTrajectory.length; i++) {
            const pt = worldToScreen(
              planningTrajectory[i].x,
              planningTrajectory[i].y
            );
            ctx.lineTo(pt.x, pt.y);
          }
          ctx.stroke();
        }

        // Draw Prediction Trajectories (预测轨迹)
        const predictionCount = Object.keys(predictionTrajectories).length;
        if (predictionCount > 0) {
          if (drawCallCount % 10 === 0) {
            console.log("Drawing", predictionCount, "prediction trajectories");
          }
        } else {
          // 只在每100次绘制时打印，避免日志过多
          if (drawCallCount % 100 === 0) {
            console.warn(
              "No prediction trajectories to draw (draw call:",
              drawCallCount,
              ")"
            );
          }
        }
        for (const [obstacleId, trajectory] of Object.entries(
          predictionTrajectories
        )) {
          if (trajectory && trajectory.length > 0) {
            ctx.strokeStyle = "#ff8800"; // 橙色
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]); // 虚线样式
            ctx.beginPath();
            const start = worldToScreen(trajectory[0].x, trajectory[0].y);
            ctx.moveTo(start.x, start.y);
            for (let i = 1; i < trajectory.length; i++) {
              const pt = worldToScreen(trajectory[i].x, trajectory[i].y);
              ctx.lineTo(pt.x, pt.y);
            }
            ctx.stroke();
            ctx.setLineDash([]); // 重置为实线
          } else {
            console.warn(
              "Empty trajectory for obstacle",
              obstacleId,
              "trajectory=",
              trajectory
            );
          }
        }

        // Draw Obstacles
        obstacles.forEach((obs) => {
          const p = worldToScreen(obs.position.x, obs.position.y);

          ctx.fillStyle = "#ffcc00"; // Default yellow
          if (obs.type === "pedestrian") ctx.fillStyle = "#ff4444"; // Red
          if (obs.type === "car") ctx.fillStyle = "#4444ff"; // Blue

          ctx.beginPath();
          if (obs.type === "cone") {
            // Triangle
            ctx.moveTo(p.x, p.y - 10);
            ctx.lineTo(p.x - 8, p.y + 5);
            ctx.lineTo(p.x + 8, p.y + 5);
          } else {
            // Circle
            ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
          }
          ctx.fill();

          // Draw ID
          ctx.fillStyle = "#fff";
          ctx.font = "10px Arial";
          ctx.textAlign = "center";
          ctx.fillText(`ID:${obs.id}`, p.x, p.y - 15);
        });

        // Draw Ego Car
        drawCar();
      }

      function drawCar() {
        const p = worldToScreen(carState.x, carState.y);

        ctx.save();
        ctx.translate(p.x, p.y);
        // Canvas rotation is clockwise, math heading is usually counter-clockwise (East=0, North=90)
        // Adjust based on your coordinate system. Assuming standard math (CCW):
        // Screen Y is inverted, so +Heading should rotate CCW visually.
        // Canvas rotate() rotates CW. So we need -heading.
        ctx.rotate(-carState.heading);

        // Car Body (4.8m x 2.0m approx) -> 48px x 20px
        const length = 4.8 * PIXELS_PER_METER;
        const width = 2.0 * PIXELS_PER_METER;

        // Shadow
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-length / 2 + 5, -width / 2 + 5, length, width);

        // Body
        ctx.fillStyle = "#00d0ff";
        ctx.fillRect(-length / 2, -width / 2, length, width);

        // Headlights / Direction indicator
        ctx.fillStyle = "#fff";
        ctx.fillRect(length / 2 - 5, -width / 2 + 2, 5, 5); // Right light
        ctx.fillRect(length / 2 - 5, width / 2 - 7, 5, 5); // Left light

        // Wheels (Front are steered)
        ctx.fillStyle = "#333";
        const wheelL = 0.8 * PIXELS_PER_METER;
        const wheelW = 0.3 * PIXELS_PER_METER;

        // Rear wheels (fixed)
        ctx.fillRect(-length / 2 + 5, -width / 2 - 2, wheelL, wheelW);
        ctx.fillRect(-length / 2 + 5, width / 2 - wheelW + 2, wheelL, wheelW);

        // Front wheels (steered)
        // We need to rotate these locally
        const frontAxleX = length / 2 - 8;

        // Front Left
        ctx.save();
        ctx.translate(frontAxleX, -width / 2);
        ctx.rotate(-carState.steering); // Steer angle
        ctx.fillRect(-wheelL / 2, -wheelW / 2, wheelL, wheelW);
        ctx.restore();

        // Front Right
        ctx.save();
        ctx.translate(frontAxleX, width / 2);
        ctx.rotate(-carState.steering);
        ctx.fillRect(-wheelL / 2, -wheelW / 2, wheelL, wheelW);
        ctx.restore();

        ctx.restore();
      }

      // Start
      connect();
      // Initial draw
      draw();
    </script>
  </body>
</html>
